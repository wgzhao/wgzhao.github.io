
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>RSS,Feed,Atom简介 - Linux系统管理</title>
  <meta name="author" content="wgzhao">

  
  <meta name="description" content="什么是 Feed（以下称为提要），如何预定它？ 网志以 RSS 文档形式为其内容提供一个提要，该 RSS 文档可以通过众所周知 URL 获得。RSS 文档是一个 XML
文件，它包含大量离散的新闻项，如某个网志中的入口项（RSS 提要的例子参见 Figure 1）。由于 RSS 是 XML &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://wgzhao.github.io/2005/12/24/introduction-rss-feed-atom">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Linux系统管理" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Linux系统管理</a></h1>
  
    <h2>关注Linux系统管理，运维开发以及大数据</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com.hk/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:wgzhao.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">RSS,Feed,Atom简介</h1>
    
    
      <p class="meta">
        








  


<time datetime="2005-12-24T00:00:00+08:00" pubdate data-updated="true"></time>
        
           | <a href="#disqus_thread"
             data-disqus-identifier="http://wgzhao.github.io">Comments</a>
        
      </p>
    
  </header>


<div class="entry-content"><p>什么是 Feed（以下称为提要），如何预定它？</p>

<p>网志以 RSS 文档形式为其内容提供一个提要，该 RSS 文档可以通过众所周知 URL 获得。RSS 文档是一个 XML
文件，它包含大量离散的新闻项，如某个网志中的入口项（RSS 提要的例子参见 Figure 1）。由于 RSS 是 XML
格式文件，所以它很容易被其它程序所使用。</p>

<!--more-->


<p> RSS 聚合器是一个读取 RSS 文档并显示新闻项的程序。大多数聚合器只要输入 RSS 的 URL，使得预定提要成为可能。<br/>
 RSS使阅读网志便得容易。大多数经常阅读网志的开发人员都使用某种类型的聚合器来帮助他们有效地筛选提要内容。聚合器使得阅读网志的感觉就象是在阅读电子邮件，因为它们突出新闻项并将新闻项进行缓冲处理以便离线阅读（参见
Figure 2）。<br/>
 还有一些在线 RSS 聚合器将 RSS
提要捆绑到某个单独的网站。其优点是易于设置并且可以从任何计算机存取你的提要内容。当然，其缺点也是显而易见的，那就是在阅读时必须始终保持连接。<br/>
 RSS
是网志成为一种强大的新型信息交流形式之根本所在。在网志出现之前，大多数开发人员为了要查找到需要的内容，通常要花大量时间来筛选掉那些令人讨厌的无关的信息。<br/>
 网志通过让读者选择所要阅读的提要，将控制权交给读者，从而有效地构建自己的个性化内容流。<br/>
 其它类型的站点也能利用 RSS 的优点来聚合内容。例如，多数主流的新闻站点包括 Wired、CNet、Yahoo 和 NPR News 都提供
RSS 提要。访问 Blogdigger 和 Syndic8，你可以找到一些支持 RSS 的站点。<br/>
 微软的 MSDN 提供 RSS 提要（RSS feeds）来聚合新添加到站点的技术内容。MSDN 的 Just
Published提要是一种保持 MSDN 新文章和下载的主要方式。甚至 MSDN Magazine（MSDN 杂志）都有其自己的 RSS
提要！可以预定：<a href="http://msdn.microsoft.com/msdnmag/rss/recent.xml">http://msdn.microsoft.com/msdnmag/rss/recent.xml</a>
获得每月的更新以便查看本期有何内容？目前有许多种 RSS 聚合器可供选择，在
<a href="http://blogs.law.harvard.edu/tech/directory/5/aggregators">http://blogs.law.harvard.edu/tech/directory/5/aggregators</a>
上可以找到一个相当完整的列表。其中一些是在线聚合器，而另外一些是桌面应用程序。有些是免费的，另外一些需要付费才能使用。</p>

<p>哪个 RSS 版本是最通用的？</p>

<p>这个问题的答案要看你问的是谁，RSS 的版本有好多个，0.90、0.91、0.92、0.93、0.94、1.0 和
2.0。要弄清楚这些版本之间的差别是巨大的挑战之一。理解它们需要了解一些有关它们的历史背景。Netscape 创建了 RSS 的最初版本
0.90，起初的名字是&#8221;RDF Site Summary&#8221;或者&#8221;Rich Site Summary&#8221;（规范中说前者是正式名称）。Netscape
创建 RSS 0.90 用于其 Web 门户，这个时候，其他人看到了 RSS 的使用潜力。Userland Software 是第一个开始将
RSS 用于其网志商业产品者之一。<br/>
 版本 0.90 在很大程度上基于 W3C 的 Resource Description Framework (RDF)。许多人都认为 RDF
过于复杂，因此都建议出一个免费的简化版本 0.91。这个任务恰好就给了 Userland Software。Userland Software
便继续发展 RSS 的简化版本，随后出台的版本包括：0.92、0.93 和 0.94。为了强调其所做的简化工作，他们将 RSS
的全称定为&#8221;Really Simple Syndication&#8221;。<br/>
 正当 Userland Software 继续专注于其简化工作时，另外一组开发人员在复兴最初的 RDF 版本（0.90），因为 RSS
号称自己更灵活。他们最终发布了一个 RSS 1.0 的版本，其正式名称还是&#8221;RDF Site Summary&#8221;。由于使用
RDF，这个版本完全不同于 Userland Software 所控制的版本。Userland Software 当然不太愿意看到 RSS
1.0 似乎要取代其 0.94 版本的事实，于是出了一个新版本，并将版本号一下子跳到了 2.0。<br/>
 这就是今天的这种局面，形成了两个主要的竞争版本：一个基于 RDF
1.0，而另一个则不是（2.0），但它们两个都共用相同的名字。这是一种可怕的混乱，因为版本号导致人们误认为 2.0 是 1.0
的改进版本，而实际上它们是两个目标完全不同的规范。另一组开发人员已经下狠心着手解决这种混乱问题，通过定义新的摘要（syndication）规范来与
RSS 名字的随意性决裂。这个解决方案称为 Atom（原子）项目。本文稍后将会详细讨论。<br/>
 使用哪个版本其实是无关痛痒的，大多数 RSS 聚合机制支持所有的 RSS 版本（有些甚至支持 Atom）。最终的决定取决于你是否想使用
RDF，可谓萝卜白菜，各有所爱，它完全要看某人所信奉的 Semantic Web 概念而定。</p>

<p>RSS 1.0 和 RSS 2.0 各是什么样子？</p>

<p>RSS 1.0 和 2.0 格式所包含的核心信息相同，但其结构不一样。我提供了一个 RSS 1.0 文档（参见 Figure 1）以及一个同等的
RSS 2.0（参见 Figure 2）用于对照。<br/>
你会注意到顶行右边开始的根元素的差异，RSS 1.0 的根元素是 rdf:RDF，而 RSS 2.0 的根元素是 rss。rss
还包含一个强制版本属性用以表示所用的RSS的准确格式（可能的值包括：0.91, 0.94 等）。另一个主要差别是 RSS 1.0
文档有名字空间限定，RSS 2.0 的文档就没有。不管怎样，包含在两个文档中的信息本质上是一样的。<br/>
 两个版本都包含 channel 元素，而 channel 元素又包含三个必须的元素：title、description 和
link，其代码如下：</p>

<pre><code>&lt;channel  &gt;  
&lt;title  &gt;&lt;!-- channel 的标题 --  &gt;&lt;/title  &gt;  
&lt;description  &gt;&lt;!-- 简要描述 --  &gt;&lt;/description  &gt;  
&lt;link  &gt;&lt;!-- channel 的 URL --  &gt;&lt;/link  &gt;  
&lt;!-- 可选/可扩展元素 --  &gt;  
&lt;/channel  &gt;  
</code></pre>

<p> 除了这些必须的元素外，RSS 1.0 还定义了三个附加元素：image、items 和 textinput，其中，image 和
textinput 是可选的。另一方面，RSS 2.0 提供了 16 个附加元素，其中也包括 image、items 和
textinput，此外还有 language、copyright、managingEditor、pubDate 和 category。RSS
1.0 允许通过定义在单独的 XML 名字空间中的可扩展元素来创建这种类型的元数据。<br/>
 这两种格式在结构上的主要区别必须要看其 item、image 和 textinput 节点的表示形式。RSS 1.0 中，channel
元素包含对 item、image 和 textinput 节点的引用，这些节点存在于 channel 节点本身之外。这样在 channel 和
所引用的节点之间建立了一种 RDF 关联。如 Figure 1 所示，channel 元素与一个 image 元素以及两个 item
元素关联。RSS 2.0 中，item 元素只是在 channel 元素中连续排放（如 Figure 2 所示）。item
元素包含实际的新闻项信息。item 的结构在两个版本中是相同的。item 元素通常包含 title、link 和 description
元素，如下代码所示：</p>

<pre><code>&lt;item  &gt;  
&lt;title  &gt;&lt;!-- 项标题 --  &gt;&lt;/title  &gt;  
&lt;link  &gt;&lt;!-- 项 URL --  &gt;&lt;/link  &gt;  
&lt;description  &gt;&lt;!-- 简要描述 --  &gt;&lt;/description  &gt;  
&lt;!-- 可选的/可扩展的元素 --  &gt;  
&lt;/item  &gt;  
</code></pre>

<p> 在 RSS 1.0 中，title 和 link 是必须的，description 是可选的。而在 RSS 2.0 中，title 或
description 必须提供其中的一个；其它均可选。这些只是定义在 RSS 1.0 中的 item 元素。RSS 2.0
提供几个其它可选元素，其中有 author、category、comments、enclosure、guid、pubDate 和
source。RSS 1.0 获取这样的元数据是通过定义在单独的 XML 名字空间中称为 RSS 模块的可扩展元素来实现的。例如，在
Figure 1 中，item 的日期是用 Dublic Core 模块的 <code>&lt;dc:date&gt;</code> 元素表示的。</p>

<p>有关不同格式的完整信息请参考 RSS 1.0 和 2.0 规范。</p>

<p>那么，何为 Atom？</p>

<p>前面我提到过，Atom 乃一项目的名字，主要是开发一个新的网志摘要格式以解决目前 RSS
存在的问题（混乱的版本号，不是一个真正的开放标准，表示方法的不一致，定义贫乏等等）。Atom
希望提供一个清晰的版本以解决每个人的需要，其设计完全不依赖于供货商，任何人都可以对之进行自由扩展，完整详细说明。<br/>
 当今许多 Blog 引擎已经支持当前的摘要格式。Figure 3 是一个Atom 0.3 提要例子，它与前述 Figure 1 及
Figure 2 RSS 提要等同。注意 Atom 提要用名字空间限定的，但它不使用 RDF。这使得 Atom 和 RSS 1.0 及 RSS
2.0 在某些地方有相似之处。Atom 在未来是否能被接受，人们拭目以待。<br/>
 除了定义新的摘要格式之外，Atom 还希望定义一个标准的档案文件格式和一个标准的网志编辑 API（Atom API）。有关 Atom
详细规范以及其它 Atom 资源请访问 The Atom Project。</p>

<p>什么是 blogroll？</p>

<p>blogroll 是网志提要的集合，大多数 blogger（博客）在其个人网志上都提供
blogroll。这就允许读者连接到其他趣味和写作风格相投的人的网志上。Blogroll 方便了网络上的沟通。通过使用Outline
Processor Markup Language （OPML），人们可以用 XML 格式文件交换 blogroll。Figure 4 是
blogroll 的一个例子。<br/>
 大多数网志引擎都自己管理 blogroll，每当读者请求 blogroll 时都自己产生相应的 XML 格式。同样，大多数聚合器都能导入
blogroll 并自动预定所包含的摘要。有关 OPML 更多的信息参见
<a href="http://opml.scripting.com/">http://opml.scripting.com</a>。</p>

<p>能解释 referrers、trackbacks 和 pingbacks 是什么吗？</p>

<p>大多数网志软件都能让读者添加网志评论。但更常见的做法是让读者在其自己的网志添加一个入口回链到原来的帖子。博客们（Bloggers）都乐于跟踪连接发生的时间以便新读者能理解整个会话内容。<br/>
 所谓 referrer
是一个外部站点，用户单击该站点上一个超链接便可以到达你的网站。许多网志引擎当读者导航到你的网志的某个入口时都能自动保持跟踪。大多数引擎都会在网志入口底部显示一个
referrers 清单，以便读者能往回导航到 referrer
的站点，并清楚他们关于该入口要说些什么，这基于一个假设，那就是如果他们链接到它，可能就此会写些什么。referrer
存在的问题是必须要有这个假设才成立&mdash;没有足够的信息说明是否引用的页面事实上包含有关信息。实际上，垃圾信息的发布者为了营销企图已经利用了这个漏洞来重定向读者。<br/>
 Trackback 和 pingback 同一个规范，被用来弥补上述问题的方案。使用 trackback 和
pingback，其他博客们能自动发送一个 ping 到你的网志以明确表示他们已经写了一个引用特定帖子的入口。<br/>
 这种类型的反链允许你的网志以更明显的方式显示所有评论的清单。当今大多数网志软件支持所有这些技术。参见 TrackBack Technical
Specification 和 Pingback 1.0。</p>

<p>如何为我的站点产生 RSS 提要？</p>

<p>Figure 5 举例说明了如何用 asp:Repeater 控件在 .aspx 页面中生成 RSS 2.0
提要。该页面假设你已经在后端代码文件中将控件的 DataSource 属性设置成对应的数据库结果集。</p>

<p>我想聚合几个 RSS 提要并将信息显示在个人网站上，能解释一下如何实现吗？</p>

<p>因为 RSS 提要是 XML 文件，作为练习，你可以用自己最擅长的 XML API，比如，Microsoft .NET Framework 中的
System.Xml，Figure 6 中包含 ASP.NET Web 用户控件代码，它是我编写用来聚合 blogroll
文件中（.opml）所列出的 RSS 提要的一段代码。这段代码假设 opml 元素包含 numberToDisplay
属性，以表示你打算显示的每个提要有多少项。</p>

<p>Figure 7 ASP.NET Web 用户控件</p>

<p>你可以将控件拖到任何 .aspx 页面中，它将显示 blogroll 文件中列出的不同提要的项，Figure 7 显示了 Utah .NET
User Group 网站使用这个控件的效果画面。</p>

<p>有没有与网志交互的 Web Services APIs？</p>

<p>许多网志引擎都提供属于自己的 Web service 接口，通过编程与网志交互，但目前还没有出现一种标准化的东西。<br/>
.Text 和 dasBlog 两者都提供某些 .asmx 端点，可以通过 SOAP 来实现编辑功能，但其接口是不同的。Blogger.com
提供基于 XML-RPC 的交互式 API （Blogger API）。Userland Software 对Blogger API
的功能进行了增强，并把它叫做 MetaWeblog API。这些可能是当今公认的网志
APIs，但仍然不是所有网志引擎都支持的。还有一个用于添加评论的独力的 API 叫做 Comment API，同样，它也不是被普遍支持。<br/>
 Atom 组正在努力解决这些问题，Atom API 定义了一个标准的网志 API 用于发布和编辑网志内容。有关信息请参考 The Atom
Project 网站。</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">wgzhao</span></span>

      








  


<time datetime="2005-12-24T00:00:00+08:00" pubdate data-updated="true"></time>
      

<span class="categories">
  
    <a class='category' href='//categories/linuxji-zhu/'>Linux技术</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="//twitter.com/share" class="twitter-share-button" data-url="http://wgzhao.github.io/2005/12/24/introduction-rss-feed-atom/" data-via="mlsx" data-counturl="http://wgzhao.github.io/2005/12/24/introduction-rss-feed-atom/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/2005/12/24/Credit-card-repayment-time/" title="Previous Post: 信用卡还款时间计算">&laquo; 信用卡还款时间计算</a>
      
      
        <a class="basic-alignment right" href="/2005/12/24/zoundry-offline-blog-editor-and-publish-tool/" title="Next Post: 离线编辑+远程发布blog的工具：Zoundry">离线编辑+远程发布blog的工具：Zoundry &raquo;</a>
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/2013/01/14/block-youku-ads-cleanly/">彻底屏蔽优酷广告</a>
      </li>
    
      <li class="post">
        <a href="/2012/12/30/some-tips-for-mac-os-x/">一些Mac OS X 的使用技巧</a>
      </li>
    
      <li class="post">
        <a href="/2012/08/24/generate-random-strings-and-other-tips-on-postgresql/">生成随机字符串以及自动更新时间戳和返回最近插入的ID号</a>
      </li>
    
      <li class="post">
        <a href="/2012/08/22/some-way-to-io-statistics-on-linux/">Linux下的一些I/O统计工具</a>
      </li>
    
      <li class="post">
        <a href="/2012/08/21/explaining-the-postgresql-query-optimizer/">PostgreSQL查询优化简介</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/wgzhao">@wgzhao</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'wgzhao',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>


<section>
  <h1>On Delicious</h1>
  <div id="delicious"></div>
  <script type="text/javascript" src="http://feeds.delicious.com/v2/json/wgzhao?count=3&amp;sort=date&amp;callback=renderDeliciousLinks"></script>
  <p><a href="http://delicious.com/wgzhao">My Delicious Bookmarks &raquo;</a></p>
</section>

  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - wgzhao -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'wgzhao';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://wgzhao.github.io/2005/12/24/introduction-rss-feed-atom/';
        var disqus_url = 'http://wgzhao.github.io/2005/12/24/introduction-rss-feed-atom/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
