
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>PostgreSQL查询优化简介 - Linux系统管理</title>
  <meta name="author" content="wgzhao">

  
  <meta name="description" content="总结一些有关PostgreSQL查询计划，查询优化的相关内容，比较基础。 SQL是一种申明性(declared)语言，也就是说，它并不是一种程序。它没有其他编程语言里的流控制语言，比如while，也无法控制操作顺序，比如有名的&#8221;goto&#8221;。 SQL只是描述一个结果，并非过程 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://wgzhao.github.io/2012/08/21/explaining-the-postgresql-query-optimizer">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Linux系统管理" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Linux系统管理</a></h1>
  
    <h2>关注Linux系统管理，运维开发以及大数据</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com.hk/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:wgzhao.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">PostgreSQL查询优化简介</h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-08-21T12:18:00+08:00" pubdate data-updated="true">Aug 21<span>st</span>, 2012</time>
        
           | <a href="#disqus_thread"
             data-disqus-identifier="http://wgzhao.github.io">Comments</a>
        
      </p>
    
  </header>


<div class="entry-content"><p>总结一些有关<a href="http://www.postgresql.org" title="The world's most advanced open source database">PostgreSQL</a>查询计划，查询优化的相关内容，比较基础。</p>

<p>SQL是一种申明性(declared)语言，也就是说，它并不是一种程序。它没有其他编程语言里的流控制语言，比如while，也无法控制操作顺序，比如有名的&#8221;goto&#8221;。</p>

<p>SQL只是描述一个结果，并非过程。</p>

<p>结果一致，但如果过程不同，所带来的系统消耗可谓天差地远。所以所有的RDBMS里都需要有查询优化器来获得一条执行代价最小的方式来获取期望的结果。</p>

<p>在<a href="http://www.postgresql.org" title="The world's most advanced open source database">PostgreSQL</a>里，和查询优化器紧密相连的便是查询计划。</p>

<!--more-->


<h3>查询计划的目标主要是：</h3>

<ul>
<li>使得查询运行的足够快

<ul>
<li>最小化磁盘I/O</li>
<li>偏向使用顺序I/O而非随机I/O</li>
<li>最小化CPU处理</li>
</ul>
</li>
<li>处理过程不要消耗太多内存</li>
<li>传递正确的结果</li>
</ul>


<h3>查询计划的决策包括:</h3>

<ul>
<li>对表的访问策略

<ul>
<li>顺序扫描(Sequential Scan),索引扫描(Index Scan)，位图索引扫描(Bitmap Index Scan)，仅索引扫描(Index-Only Scan)</li>
</ul>
</li>
<li>表连接策略

<ul>
<li>表连接顺序</li>
<li>连接方法：嵌套循环(nested loop),合并连接(merge join)，哈希连接(hash join)</li>
<li>内连接，外连接；内表与外表</li>
</ul>
</li>
<li>分组策略

<ul>
<li>简单分组，排序分组，哈希分组</li>
</ul>
</li>
</ul>


<h3>查询成本参数</h3>

<p>在<a href="http://www.postgresql.org" title="The world's most advanced open source database">PostgreSQL</a>里，查询计划是按照成本计算的，也就是基于成本的查询计划(cost-based plan)，其中影响成本计算的参数包括(后面括号的值为其缺省值)：</p>

<ul>
<li> cpu_index_tuple_cost (0.005)</li>
<li> cpu_operator_cost (0.0025)</li>
<li> cpu_tuple_cost (0.01)</li>
<li> random_page_cost (4.0)</li>
<li> seq_page_cost (1.0)</li>
</ul>


<p>与成本计算相关的试图包括:</p>

<ul>
<li> pg_class

<ul>
<li>relpages：索引、表的页面数</li>
<li>reltuples：索引、表的记录数</li>
<li>以上这些统计信息用以计算物理操作的开销</li>
</ul>
</li>
<li> pg_stats（pg_statistic）

<ul>
<li>most_common_vals：最常使用的列值</li>
<li>most_common_freqs：最常使用的列值的频率</li>
<li>histogram_bounds：数据分布列</li>
<li>n_distinct：</li>
</ul>
</li>
</ul>


<h3>成本计算方法</h3>

<p>一个查询的总代价包括读取数据的I/O代价和其他各种操作的代价之和。
I/O代价包括顺序读取数据或索引页（<code>seq_scan_cost</code>）和随机读取数据页（<code>random_scan_cost</code>）的代价，操作代价包括处理表元组（<code>cpu_tuple_cost</code>）、处理比较操作（<code>cpu_operator_cost</code>）和处理索引元组（<code>cpu_index_tuple_cost</code>）。</p>

<p>比如，如果在一个表上做全表顺序扫描，那么其代价公式为:</p>

<p><code>Cost = seq_scan_cost*relpages + cpu_tuple_cost*reltuples</code></p>

<p>如果是在一个表上做全表顺序扫描并执行过滤，则代价公式为:</p>

<p><code>Cost = seq_scan_cost*relpages + cpu_tuple_cost*reltuples + cpu_operator_cost*reltuples</code></p>

<p>对于预算要返回的行数量，其计算公式为:</p>

<p><code>rows = reltuples*估算频率</code></p>

<p>这里，估算频率通过<code>sys_stats</code>视图中统计的列值和出现频率计算得出</p>

<h3>顺序扫描</h3>

<p>顾名思义，顺序扫描就是从头到尾将扫描表的每一条记录，此时表的所有页面都要读取一遍。其代价为页面读取（<code>relpages*seq_page_cost</code>）+元组处理(<code>reltuples*cpu_tuple_cost</code>) ,顺序扫描在任何情况下都能使用，它不需要读取索引，因此对于表，不需要预先创建索引。<br/>
顺序扫描的基本原理如下图:<br/>
<img src="/images/sql_seqscan.png" title="Sequential Scan" alt="Sequential Scan" /></p>

<p>以下几种情况是顺序扫描的最佳(或不得不)使用场景:</p>

<ul>
<li>查询表没有过滤条件</li>
<li>过滤条件无索引</li>
<li>查询的返回结果集占据了整个表的绝大多数</li>
<li>访问的表是非常小</li>
</ul>


<h3>索引扫描</h3>

<p>索引扫描，使用索引定位到元组所在的页面，读取元组，此时只读取符合索引过滤条件的元组所在的页面和少量的索引页面。<br/>
索引扫描的基本原理如下图:<br/>
<img src="/images/sql_indexscan.png" title="Index Scan" alt="Index Scan" /></p>

<p>索引扫描的代价为索引页面读取+数据页面读取+元组处理。索引扫描在一个巨量表里获取较少行时能获得相当高的性能，但是不要忘记了索引扫描基本上都是随机I/O。同时索引扫描是交替读取索引和表。</p>

<h3>仅索引扫描(in 9.2+)</h3>

<p>这是<a href="http://www.postgresql.org" title="The world's most advanced open source database">PostgreSQL</a> 9.2以上版本才有的功能，它和索引扫描有类似的功能和有点，另外，它有时可以避免读取行记录。如果一个表修改的很多，仅索引扫描可能表现不好。而且它要求所有查询的列都在索引里。</p>

<h3>位图索引扫描</h3>

<p>其原理图如下：</p>

<p><img src="/images/sql_bitmapscan.png" title="Bitmap Index Scan" alt="Bitmap Index Scan" /></p>

<ul>
<li>在检查表之前先所秒所有的索引，构成一个元组ID(Tuples-ID,TID)的位图</li>
<li>顺序读表，可以跳跃</li>
<li>结果以物理排序返回</li>
<li>对于有多个条件的组合（AND、OR），可以分别对每个条件做Bitmap Index Scan，然后再对结果进行AND或OR操作</li>
<li>处理limit很弱</li>
</ul>


<h2>连接</h2>

<h3>连接计划</h3>

<ul>
<li>修复连接顺序和连接策略无疑是查询计划中最难的部分</li>
<li>随着表数量的增加，连接方式的可能性成指数级剧增</li>
<li>当搜索空间较小，查询计划差不多是做穷举搜索</li>
<li>当搜索太大，查询计划使用启发式或基因查询优化(Genetic Query Optimization,GEQO)来限制计划时间和内存使用</li>
</ul>


<h3>连接方法</h3>

<p>当连接2个表时，可以计划用于执行表连接，每一种连接方法使用一个外表(outer)和一个内表(inner)来产生一个结果表(result).</p>

<ul>
<li>嵌套循环连接(Nested loop join)

<ul>
<li>带内表顺序扫描</li>
<li>带内表索引扫描</li>
</ul>
</li>
<li>合并连接(Merge join)</li>
<li>哈希连接(Hash join)</li>
</ul>


<h4>Nested Loop Join</h4>

<p>当内表较小时，对于外表的每一条记录，都去扫描依次内表获得匹配，其原理图如下：<br/>
<img src="/images/sql_nested_loop_seqscan.png" title="Nested loop join with inner sequential scan" alt="Nested loop join with inner seqscan" /></p>

<p>其实现的伪代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">(</span><span class="n">outer</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>  <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">(</span><span class="n">inner</span><span class="p">);</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>     <span class="k">if</span> <span class="p">(</span><span class="n">outer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span>  <span class="n">inner</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
</span><span class='line'>        <span class="n">output</span><span class="p">(</span><span class="n">outer</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">inner</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>如果内表很大，且有查询列都有索引，则每次外表的每一行都会通过内表的索引去匹配，如果成功，则返回匹配的行。基本原理如下图所示：
<img src="/images/sql_nested_loop_indexscan.png" title="Nested loop join with inner index scan" alt="Nested loop join with inner index scan" /></p>

<p>其实现的伪代码如下:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">(</span><span class="n">outer</span><span class="p">);</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span><span class='line'>  <span class="n">index_entry</span> <span class="o">=</span><span class="n">get_first_match</span><span class="p">(</span><span class="n">outer</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
</span><span class='line'>  <span class="k">while</span> <span class="p">(</span><span class="n">index_entry</span><span class="p">){</span>
</span><span class='line'>    <span class="n">output</span><span class="p">(</span><span class="n">outer</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">inner</span><span class="p">[</span><span class="n">index_entry</span><span class="p">]);</span>
</span><span class='line'>    <span class="n">index_entry</span><span class="o">=</span><span class="n">get_next_match</span><span class="p">(</span><span class="n">index_entry</span><span class="p">)</span>
</span><span class='line'>    <span class="err">``</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里的内表或外表可以是基本表，也可以是其他连接生成的结果。
该连接的代价大致和两个表大小的乘积相当，如果两个都很大的话，代价很大。
所以要求整个查询返回的结果集不能太大，要把返回子集较小表的作为外表,而且在内表的连接字段上一定要有索引。</p>

<h4>Merge Join</h4>

<p>合并连接的要点是首先将连接的两个表进行排序(使用sort/index扫描)，然后并行扫描两个表，找出相等的值返回。其基本原理见下图：<br/>
<img src="/images/sql_merge_join.png" title="Merge join" alt="Merge join" /></p>

<p>其实现伪代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">sort</span><span class="p">(</span><span class="n">outer</span><span class="p">);</span>
</span><span class='line'><span class="n">sort</span><span class="p">(</span><span class="n">inner</span><span class="p">);</span>
</span><span class='line'><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="n">save_j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="k">while</span> <span class="p">(</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">(</span><span class="n">outer</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">outer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">inner</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
</span><span class='line'>     <span class="n">output</span><span class="p">[</span><span class="n">outer</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">inner</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">outer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">inner</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">(</span><span class="n">inner</span><span class="p">)){</span>
</span><span class='line'>     <span class="n">j</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>     <span class="k">if</span> <span class="p">(</span><span class="n">outer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">inner</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
</span><span class='line'>       <span class="n">save_j</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
</span><span class='line'>  <span class="k">else</span>
</span><span class='line'>     <span class="n">i</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>     <span class="n">j</span> <span class="o">=</span> <span class="n">save_j</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>合并连接只能处理相等条件连接，比如<code>a.x = b.x</code>这样的。
根据上述原理图我们可以看出，通常情况下，一个元组只需要访问一次，但是如果外表有重复值的话，内表就需要多次扫描。比如外表是{1 2 2 3},内表是{2 2 3 4}的情况</p>

<h4>Hash Join</h4>

<p>和Merge join类似，Hash join也只能处理相等条件连接。
首先在把内表的每一行通过hash函数进行hash，从而在内存内创建一个hash表。而后针对外表的每一行进行hash，来和内存的中的hash表进行匹配。其原理图如下：</p>

<p><img src="/images/sql_hash_join.png" title="Hash Join" alt="Hash Join" /></p>

<p>其实现的伪代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">(</span><span class="n">inner</span><span class="p">);</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">hash_key</span> <span class="o">=</span> <span class="n">hash</span><span class="p">(</span><span class="n">inner</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
</span><span class='line'>    <span class="n">append</span><span class="p">(</span><span class="n">hash_store</span><span class="p">(</span><span class="n">hash_key</span><span class="p">),</span><span class="n">inner</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">(</span><span class="n">outer</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">hash_key</span> <span class="o">=</span> <span class="n">hash</span><span class="p">(</span><span class="n">outer</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">(</span><span class="n">hash_store</span><span class="p">(</span><span class="n">hash_key</span><span class="p">]);</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">outer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">hash_store</span><span class="p">[</span><span class="n">hash_key</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
</span><span class='line'>            <span class="n">output</span><span class="p">(</span><span class="n">outer</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">inner</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>什么下会导致查询计划出错</h3>

<ul>
<li>如果查询计划低估了结果集的数量，它可能会选择索引扫描(Index Scan)而不是期望的顺序扫描(Sequential Scan)，或是嵌套连接(Nested Loop)而不是Hash或者合并连接</li>
<li>如果查询计划高估了结果集的数量，则结果和上条相反</li>
</ul>

</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">wgzhao</span></span>

      








  


<time datetime="2012-08-21T12:18:00+08:00" pubdate data-updated="true">Aug 21<span>st</span>, 2012</time>
      

<span class="categories">
  
    <a class='category' href='//categories/shu-ju-ku/'>数据库</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="//twitter.com/share" class="twitter-share-button" data-url="http://wgzhao.github.io/2012/08/21/explaining-the-postgresql-query-optimizer/" data-via="mlsx" data-counturl="http://wgzhao.github.io/2012/08/21/explaining-the-postgresql-query-optimizer/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/2012/08/20/several-popular-nosql-databases-key-features-list/" title="Previous Post: 几种常见的NoSQL数据库关键特性列表">&laquo; 几种常见的NoSQL数据库关键特性列表</a>
      
      
        <a class="basic-alignment right" href="/2012/08/22/some-way-to-io-statistics-on-linux/" title="Next Post: Linux下的一些I/O统计工具">Linux下的一些I/O统计工具 &raquo;</a>
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/2014/03/16/move-to-github/">Move to Github</a>
      </li>
    
      <li class="post">
        <a href="/2012/12/30/some-tips-for-mac-os-x/">一些Mac OS X 的使用技巧</a>
      </li>
    
      <li class="post">
        <a href="/2012/08/24/generate-random-strings-and-other-tips-on-postgresql/">生成随机字符串以及自动更新时间戳和返回最近插入的ID号</a>
      </li>
    
      <li class="post">
        <a href="/2012/08/22/some-way-to-io-statistics-on-linux/">Linux下的一些I/O统计工具</a>
      </li>
    
      <li class="post">
        <a href="/2012/08/21/explaining-the-postgresql-query-optimizer/">PostgreSQL查询优化简介</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/wgzhao">@wgzhao</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'wgzhao',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>


<section>
  <h1>On Delicious</h1>
  <div id="delicious"></div>
  <script type="text/javascript" src="http://feeds.delicious.com/v2/json/wgzhao?count=3&amp;sort=date&amp;callback=renderDeliciousLinks"></script>
  <p><a href="http://delicious.com/wgzhao">My Delicious Bookmarks &raquo;</a></p>
</section>

  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - wgzhao -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'wgzhao';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://wgzhao.github.io/2012/08/21/explaining-the-postgresql-query-optimizer/';
        var disqus_url = 'http://wgzhao.github.io/2012/08/21/explaining-the-postgresql-query-optimizer/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
